```python
# 7 function 계산기 (+,-,*,/, 음수-, 거듭제곱**, 리마인더%) 
# 문자열을 입력하였을때에서 숫자로 계산이 가능해야함

# 백준 1001 a+b
#a,b=input().split()
#a=int(a)
#b=int(b)
#print(a-b)

print("계산기")

a,b=input().split()
a=int(a)
b=int(b)
def plus(a,b):
  return(a+b)
def minus(a,b):
  return(a-b)
def times(a,b):
  return(a*b)
def division(a,b):
  return(a/b)
def negation(a,b='none'):
  return(-a)
def power(a,b):
  return(a**b)
def remainder(a,b):
  return(a%b)

cal_plus=plus(a,b)
cal_minus=minus(a,b)
cal_times=times(a,b)
cal_division=division(a,b)
cal_negation=negation(a,b)
cal_power=power(a,b)
cal_remainder=remainder(a,b)

print(cal_plus, cal_minus, cal_times, cal_division, cal_negation, cal_power, cal_remainder)
print("더하기 =", cal_plus)
```



## 최대, 최소 문제

```
#a=150
#b=266
#c=427

a=int(input())
b=int(input())
c=int(input())

solve=a*b*c
solve = list(map(int,str(solve)))
ans = [0] * 10

for i in solve:
  ans[i] += 1

for x in ans:
  print(x)
```

```python
# 백준 3052, 나머지 문제
# 두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다. 
# 수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.
# '_' range 에 의해 10개의 수가 생성되는데 그 수에 대해 관심 없을때 '언더바' 사용(아무 변수 사용 가능)


ans = [0] * 42
for _ in range(10):
  n = int(input())
  i = n % 42
  ans[i] = 1
print(sum(ans))

39
40
41
42
43
44
82
83
84
85
6

```



```
## 백준 2562, 최댓값 문제

max = 0     # 자연수 이므로 0보다 큼
maxi = 0
for i in range(1,10):
  n = int( input())
  if max < n:
     max = n
     maxi = i
print(max)
print(maxi)

3
29
38
12
57
74
40
85
61
85
8
```







### 2차원 리스트 문제

- 다차원 리스트(2차원)

- 리스트의 원소로 리스트를 갖는 경우

- 파이썬에서는 2차원 리스트라고 부름

```
arr2D = [
         [1, 2, 3, 4,],
         [10, 20, 30, 40],
         [5, 6, 7, 8]
         ]


# 인덱싱 [행][열]
# print( arr2D[0] )
# print( arr2d[0][1] )

# 그래서 2차원 리스트를 전부 순회 하려면
# 중첩 루프를 이용해야 합니다.

for i in range(3):
  for j in range(4):
    print( arr2D[i][j] )
```

- 

```
# 코드업, 기초-리스트, 바둑판에 흰 돌
# 19 X 19의 리스트가 필요

a = [ [0] * 5 for _ in  range(5) ]   # 원소가 5개인 리스트가 5개가 있음

for row in a :
  for col in row :
    print(col, end=' ')
  print()

# 여기까지 바둑판
```

```
# 백준, 기초-리스트2, 바둑판에 흰 돌
# 19 X 19의 리스트가 필요
# 원소가 5개인 리스트가 5개가 있음

a = [ [0] * 5 for _ in  range(5) ]
n = int(input())
for _ in range(n):
  i, j = map(int, input().split())
  a[i-1][j-1] = 1

for row in a :
  for col in row :
    print(col, end=' ')
  print()
  
5
2 2
1 1
3 3
4 4
5 5
1 0 0 0 0 
0 1 0 0 0 
0 0 1 0 0 
0 0 0 1 0 
0 0 0 0 1 
```

```
코드업 6096 : [기초-리스트] 바둑알 십자 뒤집기(py)

a = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,],
]

x, y = 10, 10

for j in range(19):
  if j != y-1: 
    if a[x-1][j] == 1: a[x-1][j] = 0
    elif a[x-1][j] == 0: a[x-1][j] = 1
    
for i in range(19):
  if i != x-1: 
    if a[i][y-1] == 1: a[i][y-1] = 0
    elif a[i][y-1] == 0: a[i][y-1] = 1

for i in range(19):
  for j in range(19):
    print( a[i][j], end= ' ' )
  print()
  
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 
```

```
# 리스트 별찍기 1
# 별을 리스트 내에서 표현
# 2차원 리스트에 대한 인덱싱 연습

n = 5
a = [ [''] * n for _ in range(n) ]

# 리스트에 별을 채우기 위해서
# 인덱스를 생성
for i in range(n):
  for j in range(i+1):
    print( 'a[{}][{}]'.format(i, j) )
    a[i][j] = '*'

for i in range(n):
  for j in range(n):
    print(a[i][j], end='')
  print()
  
a[0][0]
a[1][0]
a[1][1]
a[2][0]
a[2][1]
a[2][2]
a[3][0]
a[3][1]
a[3][2]
a[3][3]
a[4][0]
a[4][1]
a[4][2]
a[4][3]
a[4][4]
*
**
***
****
*****
```

~~~
# 백준, 별찍기2

n = 5
a = [ [' '] * n for _ in range(n) ]

# 리스트에 별을 채우기 위해서
# 인덱스를 생성
for i in range(n):             # 3
#   for j in range(-1, -(i+2), -1): 
  for j in range(n-1, n-2-i, -1):   #  2, 
    print( 'a[{}][{}]'.format(i, j) )
    a[i][j] = '*'

for i in range(n):
  for j in range(n):
    print(a[i][j], end='')
  print()

a[0][4]
a[1][4]
a[1][3]
a[2][4]
a[2][3]
a[2][2]
a[3][4]
a[3][3]
a[3][2]
a[3][1]
a[4][4]
a[4][3]
a[4][2]
a[4][1]
a[4][0]
    *
   **
  ***
 ****
*****
~~~

```
for j in range(-1, -(i+2), -1):
for j in range(n-1, n-2-i, -1):

 print(j) 를 찍어보시면 아시겠지만, 음수 인덱싱이라서 뒤부터 시작하기 때문에 범위설정이 그렇게 해도 가능한 것 같아요
저희가 채워야할 부분이
# [0,4] / [1,3], [1,4] / [2,2], [2,3], [2,4] / [3,1], [3,2], [3,3], [3,4] / [4,0] ~ [4,4]
이렇게 되기 때문에 n-2-i부분도 변화하는 값이어야해서 그렇게 하신 것 같아요
처음에는 4만, 두번째 반복에는 3,4만 세 번째 반복에는 2,3,4 이렇게 되니까

n=5일 때, n-1은 인덱스 때문에 4부터 시작해야해서 그런 것 같구요, n-2-i는 3이 되는데, 가운데 값은 항상 -1된 값까지만 반복하기 때문에 [0,4] 한 번만 반복하는 것 같습니다
range(1,5)면 1 ~ 4까지만 해당되는 것처럼요


```

```
인덱스 별찍기 3
n = 5
a = [ [''] * n for _ in range(n) ]

for i in range(n):
  for j in range(n-i):
    a[i][j] = '*'

for i in range(n):
  for j in range(n):
    print(a[i][j], end='')
  print()

*****
****
***
**
*
```

```
n = 5
a = [ [' '] * n for _ in range(n) ]

for i in range(n):
  for j in range(i, n):
    a[i][j] = '*'

for i in range(n):
  for j in range(n):
    print(a[i][j], end='')
  print()
  
*****
 ****
  ***
   **
    *
```

```
배열의 타입(넘파이)
- 리스트와는 다르게 배열은 타입을 가집니다. 
  - 리스트는 여러개의 타입을 원소로 가질 수 있습니다. 
  - 배열은 하나의 타입만 원소로 가질 수 있습니다. 
- 배열은, 배열이 생성될 때, 원소들의 타입을 보고 기본적인 자료의 타입을 결정하게 됩니다. 

arr1D.dtype

dtype('int64')  <- 64 비트라는 의미(8바이트)
```







## 넘파이



```
arrn = np.arange(1, 51).reshape(5, 10)
arrn
array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
       [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
       [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],
       [41, 42, 43, 44, 45, 46, 47, 48, 49, 50]])


값은?       
# 14, 15, 16, 17, 24, 25, 26, 27, 34, 35, 36, 37


# 12, 22, 32
```

```
# 중복되지 않은 무작위 수를 생성
arr = np.arange(1, 46)
np.random.choice(arr, size=6, replace=False)

array([32, 31, 19, 36, 12, 28])

```



- Numpy?

  - 교제: `파이썬 철저 입문` 214p

  - 수치해석용으로 만들어진 모듈이라고 보면 됩니다.

    - 머신러닝과 같은 데이터 분석을 위해서 만들어진건 아닙니다.
    - 분야를 가리지 않고, 많이 사용
    - ML/DL에서도 많이 사용
    - 판다스도 자료의 기본 타입은 numpy를 사용 합니다.

  - 수학적 계산을 돕기 위해서 만들어진 라이브러리

  - ```python
    # numpy는 일반적으로 np로 줄여서 사용을 하게 됩니다. 
    import numpy as np
    
    ```



# 넘파이에서 지원하는 타입

1. array(배열)
   - 주로 통계분석이나, ML/DL에서 사용하는 타입
   - 배열이라고 부릅니다.
   - 파이썬의 리스트와는 다릅니다.
2. matrix
   - 수학적 계산이 필요한 경우에 많이 사용
   - 수업 시간에는 사용하지 않습니다.



## 배열의 기본속성

- ndim
  - 배열의 차원
- shape
  - 배열의 크기를 나타내고, 배열의 크기는 원소의 개수와 동일
  - 1차원 배열인 경우에는 행이 1이고, 열이 n인 배열을 의미
  - 배열의 모양은 튜플로 표현이 됩니다.

### 1차원 배열

- 파이썬의 리스트와 거의 동일

```
# 리스트를 원소로 하는 배열 객체 정도로 이해
arr1D = np.array([1, 2, 3, 4])
arr1D

array([1, 2, 3, 4])
```

자료의 차원을 확인하는 것은 매주 중요합니다.

- 자료의 차원이 다르면, 알고리즘이 동작하지 않게 됩니다.
  - 알고리즘을 직접 작성하지는 않고, 잘 만들어진 라이브러리를 이용하게 됩니다.
  - 자료의 차원을 고려해서 사용을 해야 합니다.

```
# 배열의 차원
arr1D.ndim

1
```



### 2차원 배열

- 주로 다루게 되는 배열이 2차원이 될 겁니다.
  - 자료가 대부분 2차원으로 되어있을 겁니다.
  - 수업시간에도 2차원 배열까지만 확인을 합니다.
- 리스트와 동일하게, 배열의 원소로 배열을 갖는 배열 정도로 이해



```
arr2D = np.array([
  [1, 2, 3,],
  [4, 5, 6,],
  [7, 8, 9,]
])
arr2D


array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

```
# 배열의 차원
arr2D.ndim

2
```



```
# 배열의 크기
# (행, 열)
# 행은 자료의 갯수, 열은 변수의 갯수를 의미하게 됩니다.
arr2D.shape

(3, 3)

```

